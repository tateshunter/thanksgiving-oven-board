<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Thanksgiving Command Center</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    .bar { height: 10px; border-radius: 999px; background: #1f2937; overflow: hidden; }
    .bar > div { height: 100%; background: #76ba43; transition: width .25s ease; }
    .derived-cell { color: #cbd5e1; font-weight: 600; }
    .derived-muted { color: #6b7280; }

    /* tasteful ring timers */
    .ring {
      --p: 0%;
      width: 58px;
      height: 58px;
      border-radius: 9999px;
      background:
        conic-gradient(#76ba43 var(--p), rgba(255,255,255,0.08) 0);
      display: grid;
      place-items: center;
      box-shadow: inset 0 0 0 6px rgba(0,0,0,0.6);
    }
    .ring-inner {
      width: 44px;
      height: 44px;
      border-radius: 9999px;
      background: #0a0a0a;
      display: grid;
      place-items: center;
      font-size: 10px;
      color: #e5e7eb;
      text-align: center;
      line-height: 1.1;
      padding: 2px;
      border: 1px solid rgba(255,255,255,0.06);
    }
  </style>
</head>
<body class="min-h-screen w-full bg-gradient-to-b from-neutral-950 via-neutral-950 to-neutral-900 text-neutral-100 p-4 md:p-8">
  <div class="max-w-6xl mx-auto space-y-5">

    <!-- HEADER -->
    <header class="flex items-center justify-between flex-wrap gap-3">
      <div>
        <h1 class="text-2xl md:text-4xl font-semibold tracking-tight">Thanksgiving Oven Tracker & Prep Board</h1>
        <p class="text-neutral-400 text-sm md:text-base">Plan, prep, run, and watch the whole crew in one place.</p>
      </div>

      <div class="flex items-center gap-2 flex-wrap">
        <button id="btn-save" class="bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2 text-sm hover:bg-neutral-800 transition-all duration-150 hover:-translate-y-[1px] active:translate-y-0">üíæ Save</button>
        <button id="btn-clear-all" class="bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2 text-sm hover:bg-red-900/40 hover:border-red-700 transition-all duration-150 hover:-translate-y-[1px] active:translate-y-0">üß® Clear all data</button>

        <div class="inline-flex bg-neutral-900/70 backdrop-blur border border-neutral-800 rounded-2xl p-1 shadow-sm flex-wrap">
          <button id="tab-plan" class="px-3 py-1.5 rounded-xl text-sm transition bg-neutral-800 text-white">Plan</button>
          <button id="tab-prep" class="px-3 py-1.5 rounded-xl text-sm transition text-neutral-400 hover:text-white">Prep Board</button>
          <button id="tab-run"  class="px-3 py-1.5 rounded-xl text-sm transition text-neutral-400 hover:text-white">Oven Timers</button>
          <button id="tab-dash" class="px-3 py-1.5 rounded-xl text-sm transition text-neutral-400 hover:text-white">Dashboard</button>
          <button id="tab-data" class="px-3 py-1.5 rounded-xl text-sm transition text-neutral-400 hover:text-white">Data</button>
        </div>
      </div>
    </header>

    <!-- PLAN VIEW -->
    <section id="view-plan" class="space-y-3">
      <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
        <div class="text-sm text-neutral-400">Edit rows to match your exact plan. For ‚ÄúSet oven temp,‚Äù use the Oven Temp column.</div>
        <div class="flex items-center gap-2 flex-wrap">
          <button id="btn-sort-time" class="bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2 text-sm hover:bg-neutral-800 transition-all duration-150 hover:-translate-y-[1px] active:translate-y-0">‚Üï Sort by time</button>
          <button id="btn-add-row" class="bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2 text-sm inline-flex items-center gap-2 hover:bg-neutral-800 transition-all duration-150 hover:-translate-y-[1px] active:translate-y-0">‚ûï Add row</button>
          <button id="btn-reset-template" class="bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2 text-sm hover:bg-neutral-800 transition-all duration-150 hover:-translate-y-[1px] active:translate-y-0">Reset template</button>
          <button id="btn-start-cook" class="bg-blue-500 hover:bg-blue-400 text-neutral-950 rounded-xl px-3 py-2 text-sm font-semibold inline-flex items-center gap-2 transition shadow hover:-translate-y-[1px] active:translate-y-0">‚ñ∂ Start Cook</button>
        </div>
      </div>

      <div class="overflow-x-auto rounded-2xl border border-neutral-800 shadow-sm">
        <table class="min-w-[1100px] w-full text-sm">
          <thead class="bg-neutral-900 text-neutral-200">
            <tr>
              <th class="text-left p-3 w-[140px]">Time</th>
              <th class="text-left p-3 w-[110px]">Oven Temp</th>
              <th class="text-left p-3 w-[200px]">Action</th>
              <th class="text-left p-3">Item</th>
              <th class="text-left p-3 w-[150px]">Cook Time</th>
              <th class="text-left p-3 w-[140px]">Take Out</th>
              <th class="text-left p-3 w-[160px]">Person</th>
              <th class="p-3 w-[56px]"></th>
            </tr>
          </thead>
          <tbody id="timeline-tbody"></tbody>
        </table>
      </div>
    </section>

    <!-- PREP BOARD VIEW -->
    <section id="view-prep" class="space-y-4 hidden">
      <div class="bg-neutral-900/70 backdrop-blur border border-neutral-800 rounded-3xl p-5 space-y-4 shadow-lg">
        <div class="flex items-center justify-between flex-wrap gap-3">
          <div>
            <div class="text-xs uppercase tracking-widest text-neutral-500">prep board</div>
            <div class="text-lg font-semibold">Tasks by person</div>
            <div class="text-sm text-neutral-400">Auto-seeded from your plan (only when a person is assigned). Add anything else you need.</div>
          </div>
          <div class="flex items-center gap-2">
            <button id="btn-prep-random"
              class="bg-emerald-500 hover:bg-emerald-400 text-neutral-950 rounded-xl px-3 py-2 text-sm font-semibold transition hover:-translate-y-[1px] active:translate-y-0">
              üé≤ Pick a random task
            </button>
            <button id="btn-prep-seed" class="bg-neutral-950 border border-neutral-800 rounded-xl px-3 py-2 text-sm hover:bg-neutral-800 transition-all duration-150 hover:-translate-y-[1px] active:translate-y-0">Re-seed from plan</button>
          </div>
        </div>

        <div id="prep-random-panel" class="hidden bg-neutral-950 border border-neutral-800 rounded-2xl p-4"></div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-3 bg-neutral-950 border border-neutral-800 rounded-2xl p-4">
          <input id="prep-person" class="bg-neutral-900 border border-neutral-800 rounded-lg px-3 py-2 text-sm" placeholder="Person (e.g., Emily)" />
          <input id="prep-task" class="md:col-span-2 bg-neutral-900 border border-neutral-800 rounded-lg px-3 py-2 text-sm" placeholder="Prep task (e.g., Chop onions, mix batter, set table)" />
          <button id="btn-prep-add" class="md:col-span-3 bg-blue-500 hover:bg-blue-400 text-neutral-950 rounded-xl px-3 py-2 text-sm font-semibold transition hover:-translate-y-[1px] active:translate-y-0">Add prep task</button>
        </div>

        <div class="bg-neutral-950 border border-neutral-800 rounded-2xl p-4 space-y-3">
          <div class="text-sm font-semibold">Bulk add tasks for one person</div>

          <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
            <select id="prep-bulk-person" class="bg-neutral-900 border border-neutral-800 rounded-lg px-3 py-2 text-sm">
              <option value="">Select existing person (optional)</option>
            </select>
            <input id="prep-bulk-person-new" class="md:col-span-2 bg-neutral-900 border border-neutral-800 rounded-lg px-3 py-2 text-sm" placeholder="...or type a new person name" />
          </div>

          <textarea id="prep-bulk-tasks" rows="4"
            class="w-full bg-neutral-900 border border-neutral-800 rounded-lg px-3 py-2 text-sm"
            placeholder="One task per line:
Chop onions
Make gravy
Set table"></textarea>

          <button id="btn-prep-bulk-add"
            class="w-full bg-emerald-500 hover:bg-emerald-400 text-neutral-950 rounded-xl px-3 py-2 text-sm font-semibold transition hover:-translate-y-[1px] active:translate-y-0">
            Add all tasks to this person
          </button>

          <div class="text-xs text-neutral-500">Tip: paste a list from Notes or a text doc, one task per line.</div>
        </div>

        <div id="prep-container" class="space-y-3"></div>
      </div>
    </section>

    <!-- RUN VIEW -->
    <section id="view-run" class="space-y-4 hidden">
      <div class="bg-neutral-900/70 backdrop-blur border border-neutral-800 rounded-3xl p-5 space-y-4 shadow-lg">
        <div class="flex items-center justify-between flex-wrap gap-3">
          <div id="run-started-label" class="text-sm text-neutral-400">Not started</div>
          <div class="flex items-center gap-2">
            <button id="btn-run-start" class="bg-blue-500 text-neutral-950 rounded-xl px-3 py-2 font-semibold inline-flex items-center gap-2 hidden">‚ñ∂ Start</button>
            <button id="btn-run-resume" class="bg-blue-500 text-neutral-950 rounded-xl px-3 py-2 font-semibold inline-flex items-center gap-2 hidden">‚ñ∂ Resume</button>
            <button id="btn-run-pause" class="bg-neutral-950 border border-neutral-800 rounded-xl px-3 py-2 font-semibold inline-flex items-center gap-2 hidden">‚è∏ Pause</button>
            <button id="btn-run-reset" class="bg-neutral-950 border border-neutral-800 rounded-xl px-3 py-2 inline-flex items-center gap-2 hidden">‚Ü∫ Reset</button>
          </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-3">
          <div id="final-countdown" class="lg:col-span-2 bg-neutral-950 border border-neutral-800 rounded-2xl p-5"></div>
          <div id="temp-changes" class="bg-neutral-950 border border-neutral-800 rounded-2xl p-5 space-y-2"></div>
        </div>

        <div id="no-timers" class="bg-neutral-950 border border-neutral-800 rounded-2xl p-6 text-center hidden">
          <div class="text-lg font-semibold">No timed ‚Äúput in‚Äù rows found</div>
          <div class="text-neutral-400 mt-1 text-sm">Add a planned time and numeric cook minutes to a ‚Äúput in‚Äù row.</div>
        </div>

        <div id="timers-grid" class="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-3 gap-3"></div>
      </div>
    </section>

    <!-- DASHBOARD VIEW -->
    <section id="view-dash" class="space-y-4 hidden">
      <div class="bg-neutral-900/70 backdrop-blur border border-neutral-800 rounded-3xl p-5 space-y-4 shadow-lg">
        <div class="flex items-center justify-between flex-wrap gap-3">
          <div>
            <div class="text-xs uppercase tracking-widest text-neutral-500">dashboard</div>
            <div class="text-lg font-semibold">Overall status</div>
            <div class="text-sm text-neutral-400">One glance view of prep + oven progress.</div>
          </div>
          <button id="btn-dash-refresh" class="bg-neutral-950 border border-neutral-800 rounded-xl px-3 py-2 text-sm hover:bg-neutral-800 transition-all duration-150 hover:-translate-y-[1px] active:translate-y-0">Refresh</button>
        </div>

        <div id="dash-now-next" class="bg-neutral-950 border border-neutral-800 rounded-2xl p-5 space-y-3"></div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-3">
          <div id="dash-dinner" class="lg:col-span-2 bg-neutral-950 border border-neutral-800 rounded-2xl p-5"></div>
          <div id="dash-numbers" class="bg-neutral-950 border border-neutral-800 rounded-2xl p-5 space-y-3"></div>
        </div>

        <div id="dash-bars" class="bg-neutral-950 border border-neutral-800 rounded-2xl p-5 space-y-4"></div>

        <div id="dash-by-person" class="bg-neutral-950 border border-neutral-800 rounded-2xl p-5 space-y-3"></div>
      </div>
    </section>

    <!-- DATA VIEW -->
    <section id="view-data" class="space-y-4 hidden">
      <div class="bg-neutral-900/70 backdrop-blur border border-neutral-800 rounded-3xl p-5 space-y-4 shadow-lg">
        <div class="flex items-center justify-between flex-wrap gap-3">
          <div>
            <div class="text-xs uppercase tracking-widest text-neutral-500">data</div>
            <div class="text-lg font-semibold">Cook analytics</div>
            <div class="text-sm text-neutral-400">Tap points/blocks to see details. No sideways scrolling.</div>
          </div>
          <button id="btn-data-refresh" class="bg-neutral-950 border border-neutral-800 rounded-xl px-3 py-2 text-sm hover:bg-neutral-800 transition-all duration-150 hover:-translate-y-[1px] active:translate-y-0">Refresh charts</button>
        </div>

        <div id="data-summary" class="bg-neutral-950 border border-neutral-800 rounded-2xl p-5"></div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-3">
          <div class="bg-neutral-950 border border-neutral-800 rounded-2xl p-4 space-y-3">
            <div class="text-xs uppercase tracking-widest text-neutral-500">oven gantt</div>
            <div id="data-gantt" class="w-full"></div>
            <div id="data-gantt-details" class="text-xs text-neutral-400">Tap a block for details.</div>
          </div>

          <div class="bg-neutral-950 border border-neutral-800 rounded-2xl p-4 space-y-3">
            <div class="text-xs uppercase tracking-widest text-neutral-500">oven load</div>
            <div id="data-load" class="w-full"></div>
            <div id="data-load-details" class="text-xs text-neutral-400">Tap a step point for details.</div>
          </div>
        </div>

        <div class="bg-neutral-950 border border-neutral-800 rounded-2xl p-4 space-y-3">
          <div class="text-xs uppercase tracking-widest text-neutral-500">temperature schedule</div>
          <div id="data-temps" class="w-full"></div>
          <div id="data-temps-details" class="text-xs text-neutral-400">Tap a temp change for details.</div>
        </div>
      </div>
    </section>

  </div>

<script>
/* ---------------------------
   DATA + HELPERS
----------------------------*/
const temps = ["‚Äî", 300, 325, 350, 375, 400, 425, 450];

const actions = [
  "set oven temp",
  "put in",
  "flex / oven off",
  "reheat window",
  "serve",
];

const DEFAULT_TIMELINE = [
  { time: "1:00 PM", temp: 350, action: "set oven temp", item: "", cookMin: "‚Äî", person: "" },
  { time: "1:15 PM", temp: 350, action: "put in", item: "coca cola cake", cookMin: 20, person: "" },
  { time: "1:45 PM", temp: 350, action: "put in", item: "crab dip phyllo cups", cookMin: 10, person: "" },
  { time: "1:55‚Äì2:45 PM", temp: "‚Äî", action: "flex / oven off", item: "desserts cooling, prep window", cookMin: "‚Äî", person: "" },
  { time: "2:45 PM", temp: 375, action: "set oven temp", item: "", cookMin: "‚Äî", person: "" },
  { time: "3:00 PM", temp: 375, action: "put in", item: "rolls", cookMin: 10, person: "" },
  { time: "3:10 PM", temp: 350, action: "set oven temp", item: "", cookMin: "‚Äî", person: "" },
  { time: "3:35 PM", temp: 350, action: "put in", item: "corn casserole", cookMin: 50, person: "" },
  { time: "3:55 PM", temp: 350, action: "put in", item: "pineapple casserole", cookMin: 30, person: "" },
  { time: "4:05 PM", temp: 350, action: "put in", item: "green bean casserole", cookMin: 20, person: "" },
  { time: "4:25 PM", temp: 450, action: "set oven temp", item: "", cookMin: "‚Äî", person: "" },
  { time: "4:25 PM", temp: 450, action: "put in", item: "stuffing/dressing", cookMin: 30, person: "" },
  { time: "4:55 PM", temp: 400, action: "set oven temp", item: "", cookMin: "‚Äî", person: "" },
  { time: "4:58 PM", temp: 400, action: "put in", item: "bacon wrapped asparagus", cookMin: 12, person: "" },
  { time: "5:10 PM", temp: 350, action: "set oven temp", item: "", cookMin: "‚Äî", person: "" },
  { time: "5:15 PM", temp: 350, action: "put in", item: "mac and cheese", cookMin: 30, person: "" },
  { time: "5:45 PM", temp: 350, action: "reheat window", item: "final reheat window (covered)", cookMin: 15, person: "" },
  { time: "6:00 PM", temp: "‚Äî", action: "serve", item: "everything", cookMin: "‚Äî", person: "" },
];

function uuid() { return crypto.randomUUID(); }

function fmtCountdownHours(ms) {
  const s = Math.max(0, Math.floor(ms / 1000));
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = s % 60;
  return `${h}:${String(m).padStart(2, "0")}:${String(sec).padStart(2, "0")}`;
}

function fmtCountdownShort(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const m = Math.floor(s/60);
  const sec = s%60;
  if(m >= 60) return fmtCountdownHours(ms);
  return `${m}m ${String(sec).padStart(2,"0")}s`;
}

function timeStrFromDate(d) {
  const h = d.getHours();
  const m = d.getMinutes();
  const ampm = h >= 12 ? "pm" : "am";
  const hh = ((h + 11) % 12) + 1;
  return `${hh}:${String(m).padStart(2, "0")} ${ampm}`;
}

function timeStrFromMinutes(totalMin) {
  if (totalMin == null) return "‚Äî";
  totalMin = ((totalMin % 1440) + 1440) % 1440;
  let hh = Math.floor(totalMin / 60);
  const mm = totalMin % 60;
  const ampm = hh >= 12 ? "pm" : "am";
  const h12 = ((hh + 11) % 12) + 1;
  return `${h12}:${String(mm).padStart(2, "0")} ${ampm}`;
}

function titleCase(str = "") {
  return str.toLowerCase().trim().split(/ +/).filter(Boolean)
    .map(w => w[0].toUpperCase() + w.slice(1)).join(" ");
}

function normalizePerson(str = "") {
  const trimmed = String(str || "").trim();
  if (!trimmed) return "";
  return trimmed
    .toLowerCase()
    .split(/\s+/)
    .filter(Boolean)
    .map(w => w[0].toUpperCase() + w.slice(1))
    .join(" ");
}

function safeId(str = "") {
  return String(str || "").replace(/[^a-z0-9_-]/gi, "_");
}

function capFirst(str = "") {
  if (!str) return str;
  return str[0].toUpperCase() + str.slice(1);
}

function parseTimeToMinutes(raw) {
  if (!raw) return null;
  const s = String(raw).trim();
  if (!s) return null;
  const firstPart = s.split("‚Äì")[0].split("-")[0].trim();
  const m = firstPart.match(/([0-9]{1,2}) *: *([0-9]{2}) *(am|pm)/i);
  if (!m) return null;
  let hh = parseInt(m[1], 10);
  const mm = parseInt(m[2], 10);
  const ap = m[3].toLowerCase();
  if (ap === "pm" && hh !== 12) hh += 12;
  if (ap === "am" && hh === 12) hh = 0;
  return hh * 60 + mm;
}

function taskTotals(tasksArr){
  const parentsTotal = tasksArr.length;
  const parentsDone  = tasksArr.filter(t => t.done).length;

  let subsTotal = 0;
  let subsDone  = 0;

  tasksArr.forEach(t => {
    const subs = Array.isArray(t.subtasks) ? t.subtasks : [];
    subsTotal += subs.length;
    subsDone  += subs.filter(s => s.done).length;
  });

  return {
    parentsTotal, parentsDone,
    subsTotal, subsDone,
    grandTotal: parentsTotal + subsTotal,
    grandDone: parentsDone + subsDone
  };
}

function ringHTML(pct, label){
  const p = Math.max(0, Math.min(100, pct || 0));
  return `
    <div class="ring shrink-0" style="--p:${p}%">
      <div class="ring-inner">${label || ""}</div>
    </div>
  `;
}

/* ---------------------------
   STATE
----------------------------*/
let timeline = DEFAULT_TIMELINE.map(r => ({ id: uuid(), ...r }));
let view = "plan";
let sortAsc = true;

let startedAtTs = null;
let isRunning = false;
let pausedAtTs = null;
let pausedAccumMs = 0;
let tickInterval = null;

let prepTasks = [];

let acknowledgedDoneIds = new Set();
let chimeFiredInIds = new Set();

let activeDelay = null;

let dataSelected = { gantt: null, load: null, temps: null };

/* ---------------------------
   AUDIO
----------------------------*/
let audioCtx = null;
const fallbackBeep = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=");
fallbackBeep.volume = 0.25;

function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
}

function unlockAudioOnFirstGesture(){
  const unlock = () => {
    ensureAudio();
    window.removeEventListener("touchstart", unlock);
    window.removeEventListener("click", unlock);
  };
  window.addEventListener("touchstart", unlock, { once:true });
  window.addEventListener("click", unlock, { once:true });
}
unlockAudioOnFirstGesture();

function playPutInChime() {
  ensureAudio();
  try {
    const now = audioCtx.currentTime;
    const makeTone = (freq, start, dur, vol=0.18) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.0001, start);
      gain.gain.exponentialRampToValueAtTime(vol, start + 0.03);
      gain.gain.exponentialRampToValueAtTime(0.0001, start + dur);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(start);
      osc.stop(start + dur + 0.02);
    };
    makeTone(1046.5, now, 0.35);
    makeTone(783.99, now + 0.22, 0.45);
  } catch {
    fallbackBeep.currentTime = 0;
    fallbackBeep.play().catch(()=>{});
  }
}

/* ---------------------------
   PERSISTENCE
----------------------------*/
const STORAGE_KEY = "thanksgiving-oven-board:v11";

function saveState(silent=false) {
  try {
    const payload = {
      timeline,
      prepTasks,
      startedAtTs,
      isRunning,
      pausedAtTs,
      pausedAccumMs,
      activeDelay,
      view,
      sortAsc,
      acknowledgedDoneIds: [...acknowledgedDoneIds],
      chimeFiredInIds: [...chimeFiredInIds],
      dataSelected,
      savedAt: Date.now(),
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    if(!silent) flashSaved();
  } catch (err) {
    console.warn("Save failed:", err);
  }
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    const data = JSON.parse(raw);

    if (Array.isArray(data.timeline)) timeline = data.timeline;

    if (Array.isArray(data.prepTasks)) {
      prepTasks = data.prepTasks.map(t => ({
        subtasks: [],
        ...t,
        subtasks: Array.isArray(t.subtasks) ? t.subtasks : []
      }));
    }

    startedAtTs = data.startedAtTs ?? null;
    isRunning = data.isRunning ?? false;
    pausedAtTs = data.pausedAtTs ?? null;
    pausedAccumMs = data.pausedAccumMs ?? 0;

    activeDelay = (data.activeDelay && data.activeDelay.itemId && data.activeDelay.startTs)
      ? data.activeDelay
      : null;

    view = data.view ?? "plan";
    sortAsc = data.sortAsc ?? true;

    if (Array.isArray(data.acknowledgedDoneIds)) {
      acknowledgedDoneIds = new Set(data.acknowledgedDoneIds);
    }
    if (Array.isArray(data.chimeFiredInIds)) {
      chimeFiredInIds = new Set(data.chimeFiredInIds);
    }
    if (data.dataSelected) dataSelected = data.dataSelected;

    return true;
  } catch (err) {
    console.warn("Load failed:", err);
    return false;
  }
}

function clearState() { localStorage.removeItem(STORAGE_KEY); }

function flashSaved() {
  const btn = document.getElementById("btn-save");
  if (!btn) return;
  const old = btn.textContent;
  btn.textContent = "‚úÖ Saved";
  setTimeout(() => (btn.textContent = old), 900);
}

window.addEventListener("beforeunload", () => saveState(true));

/* ---------------------------
   DOM REFS
----------------------------*/
const tabPlan = document.getElementById("tab-plan");
const tabPrep = document.getElementById("tab-prep");
const tabRun  = document.getElementById("tab-run");
const tabDash = document.getElementById("tab-dash");
const tabData = document.getElementById("tab-data");

const viewPlan = document.getElementById("view-plan");
const viewPrep = document.getElementById("view-prep");
const viewRun  = document.getElementById("view-run");
const viewDash = document.getElementById("view-dash");
const viewData = document.getElementById("view-data");

const tbody = document.getElementById("timeline-tbody");

const btnSortTime = document.getElementById("btn-sort-time");
const btnAddRow = document.getElementById("btn-add-row");
const btnResetTemplate = document.getElementById("btn-reset-template");
const btnStartCook = document.getElementById("btn-start-cook");

const runStartedLabel = document.getElementById("run-started-label");
const btnRunStart  = document.getElementById("btn-run-start");
const btnRunPause  = document.getElementById("btn-run-pause");
const btnRunResume = document.getElementById("btn-run-resume");
const btnRunReset  = document.getElementById("btn-run-reset");

const noTimers = document.getElementById("no-timers");
const timersGrid = document.getElementById("timers-grid");
const finalCountdownBox = document.getElementById("final-countdown");
const tempChangesBox = document.getElementById("temp-changes");

const prepContainer = document.getElementById("prep-container");
const prepPersonInput = document.getElementById("prep-person");
const prepTaskInput = document.getElementById("prep-task");
const btnPrepAdd = document.getElementById("btn-prep-add");
const btnPrepSeed = document.getElementById("btn-prep-seed");
const btnPrepRandom = document.getElementById("btn-prep-random");
const prepRandomPanel = document.getElementById("prep-random-panel");

const prepBulkPersonSelect = document.getElementById("prep-bulk-person");
const prepBulkPersonNewInput = document.getElementById("prep-bulk-person-new");
const prepBulkTasksTextarea = document.getElementById("prep-bulk-tasks");
const btnPrepBulkAdd = document.getElementById("btn-prep-bulk-add");

const dashNowNext = document.getElementById("dash-now-next");
const dashDinner = document.getElementById("dash-dinner");
const dashNumbers = document.getElementById("dash-numbers");
const dashBars = document.getElementById("dash-bars");
const dashByPerson = document.getElementById("dash-by-person");
const btnDashRefresh = document.getElementById("btn-dash-refresh");

const dataSummary = document.getElementById("data-summary");
const dataGantt = document.getElementById("data-gantt");
const dataLoad = document.getElementById("data-load");
const dataTemps = document.getElementById("data-temps");
const dataGanttDetails = document.getElementById("data-gantt-details");
const dataLoadDetails = document.getElementById("data-load-details");
const dataTempsDetails = document.getElementById("data-temps-details");
const btnDataRefresh = document.getElementById("btn-data-refresh");

const btnSave = document.getElementById("btn-save");
const btnClearAll = document.getElementById("btn-clear-all");

/* ---------------------------
   PLAN TABLE
----------------------------*/
function derivedTakeOutForRow(r) {
  const plannedMin = parseTimeToMinutes(r.time);
  if (plannedMin == null) return null;
  if (r.action !== "put in") return null;

  const dur = typeof r.cookMin === "number" ? r.cookMin : parseInt(r.cookMin, 10);
  if (!Number.isFinite(dur)) return null;

  return timeStrFromMinutes(plannedMin + dur);
}

function hasStarted(){ return !!startedAtTs; }
function effectiveNowTs(){ return isRunning ? Date.now() : (pausedAtTs || Date.now()); }
function elapsedMs(){ return !startedAtTs ? 0 : Math.max(0, effectiveNowTs()-startedAtTs-pausedAccumMs); }

let timerItems = [];
let tempChangeItems = [];
let anchorMin = null;
let finalDoneOffsetMs = null;
let dinnerOffsetMs = null;

const TEMP_CHANGE_ACTIONS = new Set(["set oven temp"]);
function isTimedPutIn(row) {
  return row.action === "put in"
    && Number.isFinite(row.cookMin)
    && parseTimeToMinutes(row.time) != null;
}
function isTempChange(row) {
  return TEMP_CHANGE_ACTIONS.has(row.action) && parseTimeToMinutes(row.time) != null;
}

/* live row color helper for Plan */
function getPlanRowLiveStyle(r){
  if(!hasStarted() || anchorMin == null) return null;

  const plannedMin = parseTimeToMinutes(r.time);
  if(plannedMin == null) return null;
  const offsetMs = (plannedMin - anchorMin) * 60000;
  const eMs = elapsedMs();

  const cookMin = Number.isFinite(r.cookMin) ? r.cookMin : parseInt(r.cookMin, 10);
  const isTimedPutIn = r.action === "put in" && Number.isFinite(cookMin);

  if(!isTimedPutIn) return null;

  const inMs = offsetMs;
  const doneMs = offsetMs + cookMin*60000;

  if(eMs >= doneMs){
    if(acknowledgedDoneIds.has(r.id)) return "done";
    return "overdue";
  }
  if(eMs >= inMs) return "ongoing";
  return "upcoming";
}

function renderPlan() {
  tbody.innerHTML = "";
  timeline.forEach((r, idx) => {
    const tr = document.createElement("tr");

    const liveStyle = getPlanRowLiveStyle(r);
    if(liveStyle === "done"){
      tr.className = "bg-emerald-900/30 border-t border-emerald-700/40";
    } else if(liveStyle === "ongoing"){
      tr.className = "bg-amber-900/25 border-t border-amber-700/40";
    } else if(liveStyle === "overdue"){
      tr.className = "bg-rose-900/25 border-t border-rose-700/40";
    } else {
      tr.className = idx % 2 ? "bg-neutral-950" : "bg-neutral-900/40";
    }

    const tdTime = document.createElement("td");
    tdTime.className = "p-2";
    tdTime.innerHTML = `<input class="w-full bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1" placeholder="e.g., 3:35 PM" value="${r.time ?? ""}">`;
    const timeInput = tdTime.querySelector("input");

    const tdTemp = document.createElement("td");
    tdTemp.className = "p-2";
    const tempOptions = temps.map(t => `<option value="${t}" ${String(r.temp)===String(t)?"selected":""}>${t==="‚Äî"?"‚Äî":t+"¬∞F"}</option>`).join("");
    tdTemp.innerHTML = `<select class="w-full bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1">${tempOptions}</select>`;

    const tdAction = document.createElement("td");
    tdAction.className = "p-2";
    const actionOptions = actions.map(a => `<option value="${a}" ${r.action===a?"selected":""}>${capFirst(a)}</option>`).join("");
    tdAction.innerHTML = `<select class="w-full bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1">${actionOptions}</select>`;

    const tdItem = document.createElement("td");
    tdItem.className = "p-2";
    tdItem.innerHTML = `<input class="w-full bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1" placeholder="dish or note" value="${r.item ?? ""}">`;
    const itemInput = tdItem.querySelector("input");

    const tdCook = document.createElement("td");
    tdCook.className = "p-2";
    tdCook.innerHTML = `<input class="w-full bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1" placeholder="min or ‚Äî" value="${r.cookMin ?? ""}">`;
    const cookInput = tdCook.querySelector("input");

    const tdTakeOut = document.createElement("td");
    tdTakeOut.className = "p-2";
    function refreshTakeOutCell(){
      const takeOutStr = derivedTakeOutForRow(r);
      tdTakeOut.innerHTML = takeOutStr
        ? `<div class="derived-cell">${takeOutStr}</div>`
        : `<div class="derived-muted">‚Äî</div>`;
    }
    refreshTakeOutCell();

    const tdPerson = document.createElement("td");
    tdPerson.className = "p-2";
    tdPerson.innerHTML = `<input class="w-full bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1" placeholder="who's on it?" value="${r.person ?? ""}">`;
    const personInput = tdPerson.querySelector("input");

    const tdDel = document.createElement("td");
    tdDel.className = "p-2 text-right";
    tdDel.innerHTML = `<button class="text-neutral-400 hover:text-red-400" title="delete row">üóë</button>`;

    /* events (NO full rerender on blur -> fixes click-out issue) */
    timeInput.addEventListener("input", (e) => {
      r.time = e.target.value;
      rebuildTimers();
      refreshTakeOutCell();
      saveState(true);
    });

    tdTemp.querySelector("select").addEventListener("change", (e) => {
      r.temp = e.target.value === "‚Äî" ? "‚Äî" : parseInt(e.target.value, 10);
      rebuildTimers(); seedPrepTasks(false); refreshTakeOutCell(); saveState(true);
    });

    tdAction.querySelector("select").addEventListener("change", (e) => {
      r.action = e.target.value;
      rebuildTimers(); seedPrepTasks(false); refreshTakeOutCell(); saveState(true);
    });

    itemInput.addEventListener("input", (e) => {
      r.item = e.target.value;
      rebuildTimers(); seedPrepTasks(false); saveState(true);
    });

    cookInput.addEventListener("input", (e) => {
      // allow typing freely; coerce later only if numeric
      const v = e.target.value.trim();
      r.cookMin = v === "" ? "" : (v === "‚Äî" ? "‚Äî" : (Number.isFinite(Number(v)) ? Number(v) : v));
      rebuildTimers();
      refreshTakeOutCell();
      saveState(true);
    });

    personInput.addEventListener("input", (e) => {
      r.person = e.target.value;
      seedPrepTasks(false);
      saveState(true);
    });
    personInput.addEventListener("blur", (e) => {
      r.person = normalizePerson(e.target.value);
      e.target.value = r.person;
      seedPrepTasks(true);
      saveState(true);
    });

    tdDel.querySelector("button").addEventListener("click", () => {
      timeline = timeline.filter(x => x.id !== r.id);
      prepTasks = prepTasks.filter(t => t.sourceRowId !== r.id);
      renderPlan(); rebuildTimers(); seedPrepTasks(false); renderPrep(); renderDash(); renderData(); saveState(true);
    });

    tr.append(tdTime, tdTemp, tdAction, tdItem, tdCook, tdTakeOut, tdPerson, tdDel);
    tbody.appendChild(tr);
  });
}

function sortTimelineByTime() {
  sortAsc = !sortAsc;
  const dir = sortAsc ? 1 : -1;

  timeline.sort((a,b) => {
    const ta = parseTimeToMinutes(a.time);
    const tb = parseTimeToMinutes(b.time);
    if (ta == null && tb == null) return 0;
    if (ta == null) return 1;
    if (tb == null) return -1;
    return (ta - tb) * dir;
  });

  renderPlan();
  rebuildTimers();
  seedPrepTasks(false);
  saveState();
}

/* ---------------------------
   TIMERS / RUN VIEW
----------------------------*/
function rebuildTimers() {
  const parseableTimes = timeline.map(r => parseTimeToMinutes(r.time)).filter(v => v != null);
  if (!parseableTimes.length) {
    timerItems=[]; tempChangeItems=[]; anchorMin=null; finalDoneOffsetMs=null; dinnerOffsetMs=null;
    renderRun(); renderDash(); renderData(); renderPlan();
    return;
  }
  anchorMin = Math.min(...parseableTimes);

  timerItems = timeline.filter(isTimedPutIn).map(r => {
    const plannedMin = parseTimeToMinutes(r.time);
    const dur = Number(r.cookMin);
    const inOffsetMin = plannedMin - anchorMin;
    const doneOffsetMin = inOffsetMin + dur;
    return {
      id:r.id, item:r.item, person:r.person, temp:r.temp, plannedTime:r.time, cookMin:dur,
      inOffsetMs: inOffsetMin*60000, doneOffsetMs: doneOffsetMin*60000
    };
  }).sort((a,b)=>a.inOffsetMs-b.inOffsetMs);

  finalDoneOffsetMs = timerItems.length ? Math.max(...timerItems.map(t=>t.doneOffsetMs)) : null;

  tempChangeItems = timeline.filter(isTempChange).map(r => {
    const plannedMin = parseTimeToMinutes(r.time);
    const offsetMin = plannedMin - anchorMin;
    const targetTemp = r.temp !== "‚Äî" ? r.temp : null;
    return { id:r.id, time:r.time, action:r.action, item:r.item, targetTemp, offsetMs: offsetMin*60000 };
  }).sort((a,b)=>a.offsetMs-b.offsetMs);

  const serveRow = timeline.find(r =>
    String(r.action||"").toLowerCase().trim()==="serve" &&
    parseTimeToMinutes(r.time)!=null
  );

  dinnerOffsetMs = serveRow
    ? (parseTimeToMinutes(serveRow.time) - anchorMin) * 60000
    : finalDoneOffsetMs;

  renderRun(); renderDash(); renderData(); renderPlan();
}

function nowOffsetMs(){ return elapsedMs(); }

function renderRun(){
  btnRunReset.classList.toggle("hidden", !startedAtTs);
  btnRunPause.classList.toggle("hidden", !(startedAtTs && isRunning));
  btnRunResume.classList.toggle("hidden", !(startedAtTs && !isRunning));
  btnRunStart.classList.toggle("hidden", !!startedAtTs);

  runStartedLabel.textContent = startedAtTs
    ? `Started ${timeStrFromDate(new Date(startedAtTs))} (anchor = first planned time)`
    : "Not started";

  timersGrid.innerHTML = "";

  if(!startedAtTs || finalDoneOffsetMs==null){
    finalCountdownBox.innerHTML = `
      <div class="text-xs uppercase tracking-widest text-neutral-500">final countdown</div>
      <div class="text-2xl font-semibold mt-1">Start cook to see final timer</div>
      <div class="text-neutral-400 text-sm mt-1">Time until the last timed dish is done.</div>`;
  } else {
    const remainingFinalMs = Math.max(0, finalDoneOffsetMs - elapsedMs());
    const targetFinalTs = effectiveNowTs() + remainingFinalMs;
    const finalPct = finalDoneOffsetMs ? Math.round((elapsedMs()/finalDoneOffsetMs)*100) : 0;

    finalCountdownBox.innerHTML = `
      <div class="flex items-start justify-between gap-3">
        <div>
          <div class="text-xs uppercase tracking-widest text-neutral-500">final countdown</div>
          <div class="text-5xl md:text-6xl font-bold mt-2">${fmtCountdownHours(remainingFinalMs)}</div>
          <div class="text-neutral-300 mt-2 text-sm">Until the last thing is done</div>
        </div>
        <div class="flex items-center gap-3">
          ${ringHTML(finalPct, "final")}
          <div class="text-right">
            <div class="text-xs text-neutral-500 uppercase tracking-widest">done at</div>
            <div class="text-2xl font-semibold mt-1">${timeStrFromDate(new Date(targetFinalTs))}</div>
          </div>
        </div>
      </div>`;
  }

  if(!tempChangeItems.length){
    tempChangesBox.innerHTML = `<div class="text-xs uppercase tracking-widest text-neutral-500">oven temp changes</div><div class="text-sm text-neutral-400">No planned temp changes found.</div>`;
  } else {
    const eMs = elapsedMs();
    tempChangesBox.innerHTML = `
      <div class="text-xs uppercase tracking-widest text-neutral-500">oven temp changes</div>
      <div class="space-y-2">
      ${tempChangeItems.map(tc=>{
        const rem = tc.offsetMs - eMs;
        const due = rem<=0;
        const tempText = tc.targetTemp ? `${tc.targetTemp}¬∞F` : "‚Äî";
        return `<div class="flex items-center justify-between bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2">
          <div><div class="text-sm font-medium">Set temp ‚Üí ${tempText}</div><div class="text-xs text-neutral-400">Planned: ${tc.time}</div></div>
          <div class="text-sm font-semibold ${due?"text-amber-300":"text-neutral-100"}">${due?"NOW":fmtCountdownHours(rem)}</div>
        </div>`;
      }).join("")}
      </div>`;
  }

  if(!timerItems.length){ noTimers.classList.remove("hidden"); return; }
  noTimers.classList.add("hidden");

  const eMs = elapsedMs();

  timerItems.forEach(it => {
    const dueToPutIn = eMs >= it.inOffsetMs;
    const alreadyChimed = chimeFiredInIds.has(it.id);
    if (startedAtTs && dueToPutIn && !alreadyChimed) {
      playPutInChime();
      chimeFiredInIds.add(it.id);
      saveState(true);
    }
  });

  timerItems.forEach(it=>{
    const prepLeftMs = it.inOffsetMs - eMs;
    const untilDoneMs = it.doneOffsetMs - eMs;
    const inOven = prepLeftMs<=0 && untilDoneMs>0;
    const overdue = untilDoneMs<=0;
    const isDone = acknowledgedDoneIds.has(it.id);

    let statusClass, statusText;
    if(isDone){
      statusClass = "bg-emerald-500/20 text-emerald-200 border border-emerald-500/40";
      statusText = "done";
    } else if(overdue){
      statusClass = "bg-rose-500/20 text-rose-200 border border-rose-500/40";
      statusText = "timer expired";
    } else if(inOven){
      statusClass = "bg-amber-500/20 text-amber-200 border border-amber-500/40";
      statusText = "in oven now";
    } else {
      statusClass = "bg-emerald-500/20 text-emerald-200 border border-emerald-500/40";
      statusText = "prep time left";
    }

    const cookPct = Math.max(0, Math.min(100, Math.round(((it.cookMin*60000 - untilDoneMs)/(it.cookMin*60000))*100)));

    const card = document.createElement("div");
    card.dataset.cardId = it.id;
    card.className = "border rounded-2xl p-4 space-y-3 bg-neutral-950 border-neutral-800 shadow-lg shadow-black/30";

    card.innerHTML = `
      <div class="space-y-0.5">
        <div class="text-lg font-semibold">${titleCase(it.item||"(Unnamed Dish)")}</div>
        <div class="text-xs text-neutral-400">Planned: ${it.plannedTime} ‚Ä¢ Cook ${it.cookMin} min ‚Ä¢ ${it.temp==="‚Äî"?"‚Äî":it.temp+"¬∞F"}</div>
        ${it.person ? `<div class="text-xs text-neutral-300">üë§ ${titleCase(it.person)}</div>` : ``}
      </div>

      <div class="flex items-center justify-between bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2">
        <div class="text-xs text-neutral-400">prep time left (until oven)</div>
        <div class="text-base font-semibold inline-flex items-center gap-2">‚è≤ ${fmtCountdownHours(prepLeftMs)}</div>
      </div>

      <div class="flex items-center justify-between bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2">
        <div class="text-xs text-neutral-400">time until done</div>
        <div class="flex items-center gap-2">
          ${inOven ? ringHTML(cookPct, "cook") : ""}
          <div class="text-base font-semibold inline-flex items-center gap-2">‚è≤ ${fmtCountdownHours(untilDoneMs)}</div>
        </div>
      </div>

      <div class="flex items-center justify-between">
        <div class="text-xs rounded-lg px-2 py-1 inline-block ${statusClass}">${statusText}</div>

        ${overdue && !isDone ? `
          <button
            class="bg-emerald-500 hover:bg-emerald-400 text-neutral-950 rounded-lg px-3 py-1.5 text-xs font-semibold"
            data-ack="${it.id}"
          >Item done</button>
        ` : ``}
      </div>
    `;

    timersGrid.appendChild(card);
  });

  timersGrid.querySelectorAll("[data-ack]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-ack");
      acknowledgedDoneIds.add(id);
      renderRun(); renderDash(); renderData(); renderPlan(); saveState(true);
    });
  });
}

function startRun(){
  ensureAudio();
  startedAtTs=Date.now();
  isRunning=true;
  pausedAtTs=null;
  pausedAccumMs=0;
  activeDelay=null;
  chimeFiredInIds.clear();
  setView("run");
  startTicking();
  renderRun();
  renderDash();
  renderData();
  renderPlan();
  saveState(true);
}

function pauseRun(){
  if(!isRunning) return;
  isRunning=false;
  pausedAtTs=Date.now();
  startTicking();
  renderRun();
  renderDash();
  renderData();
  renderPlan();
  saveState(true);
}

function resumeRun(){
  if(!startedAtTs) return startRun();
  if(pausedAtTs){ pausedAccumMs += (Date.now()-pausedAtTs); pausedAtTs=null; }
  isRunning=true;
  startTicking();
  renderRun();
  renderDash();
  renderData();
  renderPlan();
  saveState(true);
}

function resetRun(){
  stopTicking();
  startedAtTs=null;
  isRunning=false;
  pausedAtTs=null;
  pausedAccumMs=0;
  activeDelay=null;
  acknowledgedDoneIds.clear();
  chimeFiredInIds.clear();
  renderRun();
  renderDash();
  renderData();
  renderPlan();
  saveState(true);
}

function startTicking(){
  stopTicking();
  tickInterval=setInterval(()=>{
    renderRun();
    renderDash();
    renderData();
    renderPlan();
  },750);
}

function stopTicking(){
  if(tickInterval) clearInterval(tickInterval);
  tickInterval=null;
}

/* ---------------------------
   PREP BOARD
----------------------------*/
function seedPrepTasks(force=true){
  const rowsWithItems = timeline.filter(r => r.item && String(r.item).trim() && r.action !== "flex / oven off");

  if (force) {
    prepTasks = prepTasks.filter(t => !t.sourceRowId);
  }

  rowsWithItems.forEach(r => {
    const personName = normalizePerson(r.person);
    if (!personName) return;

    const exists = prepTasks.some(t => t.sourceRowId === r.id);
    const newTaskText = `${capFirst(r.action)} ‚Äî ${titleCase(r.item)}`;

    if (!exists) {
      prepTasks.push({
        id: uuid(),
        person: personName,
        task: newTaskText,
        done: false,
        sourceRowId: r.id,
        subtasks: [],
      });
    } else if (force) {
      prepTasks = prepTasks.map(t => t.sourceRowId===r.id
        ? { ...t, person: personName, task: newTaskText, subtasks: Array.isArray(t.subtasks)?t.subtasks:[] }
        : t
      );
    }
  });

  renderPrep();
  renderDash();
  renderData();
  saveState(true);
}

function addPrepTask(person, task){
  const p = normalizePerson(person);
  const t = String(task || "").trim();
  if(!t) return;

  prepTasks.push({ id: uuid(), person: p, task: t, done:false, subtasks: [] });

  prepPersonInput.value=""; prepTaskInput.value="";
  renderPrep(); renderDash(); renderData(); saveState(true);
}

function getAllKnownPeople(){
  const people = new Set();
  prepTasks.forEach(t => {
    const p = normalizePerson(t.person);
    if(p) people.add(p);
  });
  timeline.forEach(r => {
    const p = normalizePerson(r.person);
    if(p) people.add(p);
  });
  return [...people].sort();
}

function populateBulkPersonSelect(){
  const people = getAllKnownPeople();
  prepBulkPersonSelect.innerHTML =
    `<option value="">Select existing person (optional)</option>` +
    people.map(p => `<option value="${p}">${titleCase(p)}</option>`).join("");
}

function addPrepTasksBulk(){
  const selected = normalizePerson(prepBulkPersonSelect.value);
  const typed = normalizePerson(prepBulkPersonNewInput.value);
  const person = typed || selected;

  const raw = String(prepBulkTasksTextarea.value || "");
  const lines = raw.split("\n").map(x => x.trim()).filter(Boolean);

  if(!person || !lines.length) return;

  lines.forEach(task => prepTasks.push({ id: uuid(), person, task, done: false, subtasks: [] }));

  prepBulkPersonSelect.value = "";
  prepBulkPersonNewInput.value = "";
  prepBulkTasksTextarea.value = "";

  renderPrep(); renderDash(); renderData(); saveState(true);
}

function addSubtask(parentTaskId, text){
  const t = String(text || "").trim();
  if(!t) return;

  prepTasks = prepTasks.map(pt => {
    if(pt.id !== parentTaskId) return pt;
    const subtasks = Array.isArray(pt.subtasks) ? pt.subtasks : [];
    return { ...pt, subtasks: [...subtasks, { id: uuid(), text: t, done: false }] };
  });

  renderPrep(); renderDash(); renderData(); saveState(true);
}

function toggleSubtaskDone(parentTaskId, subId, done){
  prepTasks = prepTasks.map(pt => {
    if(pt.id !== parentTaskId) return pt;
    const subtasks = (pt.subtasks || []).map(s => s.id === subId ? { ...s, done } : s);
    return { ...pt, subtasks };
  });

  renderPrep(); renderDash(); renderData(); saveState(true);
}

function deleteSubtask(parentTaskId, subId){
  prepTasks = prepTasks.map(pt => {
    if(pt.id !== parentTaskId) return pt;
    const subtasks = (pt.subtasks || []).filter(s => s.id !== subId);
    return { ...pt, subtasks };
  });

  renderPrep(); renderDash(); renderData(); saveState(true);
}

function pickRandomPrepTask(){
  const undone = prepTasks.filter(t => !t.done && normalizePerson(t.person));
  if(!undone.length){
    prepRandomPanel.classList.remove("hidden");
    prepRandomPanel.innerHTML = `<div class="text-sm text-neutral-300">All prep tasks are done üéâ</div>`;
    return;
  }
  const idx = Math.floor(Math.random()*undone.length);
  const t = undone[idx];

  prepRandomPanel.classList.remove("hidden");
  prepRandomPanel.innerHTML = `
    <div class="flex items-start justify-between gap-3">
      <div>
        <div class="text-xs uppercase tracking-widest text-neutral-500">random task</div>
        <div class="text-lg font-semibold mt-1">${titleCase(t.task)}</div>
        <div class="text-sm text-neutral-400 mt-1">Assigned to: ${titleCase(t.person)}</div>
      </div>
      <div class="flex items-center gap-2">
        <button id="rand-mark-done"
          class="bg-emerald-500 hover:bg-emerald-400 text-neutral-950 rounded-lg px-3 py-1.5 text-xs font-semibold">
          Mark done
        </button>
        <button id="rand-close"
          class="bg-neutral-950 border border-neutral-700 hover:bg-neutral-800 text-neutral-100 rounded-lg px-3 py-1.5 text-xs font-semibold">
          Close
        </button>
      </div>
    </div>
  `;
  prepRandomPanel.querySelector("#rand-close").onclick = ()=> prepRandomPanel.classList.add("hidden");
  prepRandomPanel.querySelector("#rand-mark-done").onclick = ()=>{
    prepTasks = prepTasks.map(x => x.id===t.id ? {...x, done:true} : x);
    renderPrep(); renderDash(); renderData(); saveState(true);
    prepRandomPanel.classList.add("hidden");
  };
}

function renderPrep(){
  prepContainer.innerHTML = "";
  const visibleTasks = prepTasks.filter(t => normalizePerson(t.person));
  populateBulkPersonSelect();

  if(!visibleTasks.length){
    prepContainer.innerHTML = `<div class="text-sm text-neutral-400">No prep tasks assigned yet. Add some above and include a person.</div>`;
    return;
  }

  const byPerson = {};
  visibleTasks.forEach(t => {
    const p = normalizePerson(t.person);
    byPerson[p] = byPerson[p] || [];
    byPerson[p].push(t);
  });

  Object.keys(byPerson).sort().forEach(person => {
    const tasks = byPerson[person];
    const totals = taskTotals(tasks);

    const card = document.createElement("div");
    card.className = "bg-neutral-950 border border-neutral-800 rounded-2xl p-4 space-y-3";
    card.innerHTML = `
      <div class="flex items-center justify-between">
        <div class="text-lg font-semibold">${titleCase(person)}</div>
        <div class="text-xs text-neutral-400">
          ${totals.grandDone}/${totals.grandTotal} done
          ${totals.subsTotal ? `<span class="text-neutral-500 ml-1">(${totals.parentsTotal} tasks + ${totals.subsTotal} subtasks)</span>` : ``}
        </div>
      </div>

      <div class="flex items-center gap-2">
        <input
          class="flex-1 bg-neutral-900 border border-neutral-800 rounded-lg px-3 py-2 text-sm"
          placeholder="Add a task for ${titleCase(person)}‚Ä¶"
          data-inline-task="${person}"
        />
        <button
          class="bg-blue-500 hover:bg-blue-400 text-neutral-950 rounded-lg px-3 py-2 text-sm font-semibold transition"
          data-inline-add="${person}"
        >Add</button>
      </div>

      <div class="space-y-2" id="prep-list-${safeId(person)}"></div>
    `;
    prepContainer.appendChild(card);

    const list = card.querySelector(`#prep-list-${safeId(person)}`);

    tasks.forEach(t => {
      const subtasks = Array.isArray(t.subtasks) ? t.subtasks : [];
      const subDone = subtasks.filter(s => s.done).length;

      const taskWrap = document.createElement("div");
      taskWrap.className = "bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2 space-y-2";

      taskWrap.innerHTML = `
        <label class="flex items-center gap-2 cursor-pointer">
          <input type="checkbox" class="accent-emerald-500" ${t.done?"checked":""} data-task-check="${t.id}" />
          <span class="text-sm ${t.done?"line-through text-neutral-500":"text-neutral-100"}">${t.task}</span>
          ${subtasks.length ? `<span class="text-[11px] text-neutral-400 ml-2">${subDone}/${subtasks.length} subtasks</span>` : ``}
          <button class="ml-auto text-neutral-500 hover:text-red-400 text-xs" title="delete" data-task-del="${t.id}">delete</button>
        </label>

        <div class="space-y-1 pl-6" data-sublist="${t.id}">
          ${
            subtasks.map(s => `
              <label class="flex items-center gap-2 bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1.5 cursor-pointer">
                <input type="checkbox" class="accent-emerald-500" ${s.done?"checked":""} data-sub-check="${t.id}::${s.id}" />
                <span class="text-xs ${s.done?"line-through text-neutral-500":"text-neutral-200"}">${s.text}</span>
                <button class="ml-auto text-neutral-600 hover:text-red-400 text-[10px]" title="delete subtask" data-sub-del="${t.id}::${s.id}">delete</button>
              </label>
            `).join("")
          }
        </div>

        <div class="flex items-center gap-2 pl-6">
          <input
            class="flex-1 bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1.5 text-xs"
            placeholder="Add subtask‚Ä¶"
            data-sub-input="${t.id}"
          />
          <button
            class="bg-neutral-950 border border-neutral-700 hover:bg-neutral-800 text-neutral-100 rounded-lg px-2 py-1.5 text-xs transition"
            data-sub-add="${t.id}"
          >Add</button>
        </div>
      `;

      list.appendChild(taskWrap);
    });
  });

  prepContainer.querySelectorAll("[data-task-check]").forEach(chk => {
    chk.addEventListener("change", (e) => {
      const id = chk.getAttribute("data-task-check");
      const done = e.target.checked;
      prepTasks = prepTasks.map(x => x.id===id ? { ...x, done } : x);
      renderPrep(); renderDash(); renderData(); saveState(true);
    });
  });

  prepContainer.querySelectorAll("[data-task-del]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      const id = btn.getAttribute("data-task-del");
      prepTasks = prepTasks.filter(x => x.id !== id);
      renderPrep(); renderDash(); renderData(); saveState(true);
    });
  });

  prepContainer.querySelectorAll("[data-inline-add]").forEach(btn => {
    btn.addEventListener("click", () => {
      const person = btn.getAttribute("data-inline-add");
      const input = prepContainer.querySelector(`[data-inline-task="${person}"]`);
      const task = input.value.trim();
      if(!task) return;

      prepTasks.push({ id: uuid(), person, task, done:false, subtasks: [] });
      input.value = "";
      renderPrep(); renderDash(); renderData(); saveState(true);
    });
  });

  prepContainer.querySelectorAll("[data-sub-add]").forEach(btn => {
    btn.addEventListener("click", () => {
      const parentId = btn.getAttribute("data-sub-add");
      const input = prepContainer.querySelector(`[data-sub-input="${parentId}"]`);
      addSubtask(parentId, input.value);
      input.value = "";
    });
  });

  prepContainer.querySelectorAll("[data-sub-check]").forEach(chk => {
    chk.addEventListener("change", (e) => {
      const key = chk.getAttribute("data-sub-check");
      const [parentId, subId] = key.split("::");
      toggleSubtaskDone(parentId, subId, e.target.checked);
    });
  });

  prepContainer.querySelectorAll("[data-sub-del]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      const key = btn.getAttribute("data-sub-del");
      const [parentId, subId] = key.split("::");
      deleteSubtask(parentId, subId);
    });
  });
}

/* ---------------------------
   DASHBOARD (unchanged logic)
----------------------------*/
function getSortedPlannerEvents(){
  if(anchorMin == null) return [];
  return timeline
    .map(r=>{
      const plannedMin = parseTimeToMinutes(r.time);
      if(plannedMin == null) return null;
      return {
        id: r.id,
        action: r.action,
        temp: r.temp,
        time: r.time,
        item: r.item,
        person: r.person,
        offsetMs: (plannedMin - anchorMin) * 60000
      };
    })
    .filter(Boolean)
    .sort((a,b)=>a.offsetMs-b.offsetMs);
}

function renderDashNowNext(){
  if(!dashNowNext) return;

  if(!hasStarted() || anchorMin == null){
    const upcoming = timeline
      .map(r => ({ ...r, plannedMin: parseTimeToMinutes(r.time) }))
      .filter(r => r.plannedMin != null && r.action !== "serve")
      .sort((a,b)=>a.plannedMin-b.plannedMin)
      .slice(0,6);

    dashNowNext.innerHTML = `
      <div class="text-xs uppercase tracking-widest text-neutral-500">control tower</div>
      <div class="text-lg font-semibold">Upcoming from plan</div>
      <div class="text-sm text-neutral-400">Start cook to activate live now/next countdowns.</div>
      <div class="mt-3 space-y-2">
        ${upcoming.map(r=>`
          <div class="flex items-center justify-between bg-neutral-900 border border-neutral-800 rounded-xl px-3 py-2">
            <div>
              <div class="text-sm font-medium">${capFirst(r.action)} ‚Äî ${titleCase(r.item||"")}</div>
              <div class="text-xs text-neutral-400">${r.time}${r.action==="set oven temp" && r.temp!=="‚Äî" ? ` ‚Ä¢ ‚Üí ${r.temp}¬∞F` : ""}${r.person?` ‚Ä¢ üë§ ${titleCase(r.person)}`:""}</div>
            </div>
          </div>
        `).join("") || `<div class="text-sm text-neutral-500">No planned rows with parseable times yet.</div>`}
      </div>
    `;
    return;
  }

  const eMs = nowOffsetMs();
  const events = getSortedPlannerEvents();
  const pastEvents = events.filter(ev => ev.offsetMs <= eMs);
  const futureEvents = events.filter(ev => ev.offsetMs > eMs);

  const lastEvent = pastEvents[pastEvents.length-1] || null;
  const nextEvent = futureEvents[0] || null;

  const inOvenNow = timerItems.filter(t=>{
    const prepLeftMs = t.inOffsetMs - eMs;
    const untilDoneMs = t.doneOffsetMs - eMs;
    return prepLeftMs <= 0 && untilDoneMs > 0;
  });

  const lastTempEvent = [...pastEvents].reverse().find(ev => ev.action === "set oven temp" && ev.temp !== "‚Äî");
  const currentTemp = lastTempEvent ? lastTempEvent.temp : null;
  const runway = futureEvents.slice(0,6);

  dashNowNext.innerHTML = `
    <div class="text-xs uppercase tracking-widest text-neutral-500">control tower</div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
      <div class="bg-neutral-900 border border-neutral-800 rounded-xl p-3 space-y-2">
        <div class="text-xs uppercase tracking-widest text-neutral-500">now</div>

        ${currentTemp ? `
          <div class="text-sm">üå°Ô∏è Current target temp: <span class="font-semibold">${currentTemp}¬∞F</span></div>
        ` : `
          <div class="text-sm text-neutral-400">üå°Ô∏è No temp target active yet</div>
        `}

        ${inOvenNow.length ? `
          <div class="space-y-1">
            ${inOvenNow.map(it=>{
              const untilDoneMs = it.doneOffsetMs - eMs;
              return `
                <div class="flex items-center justify-between bg-neutral-950 border border-neutral-800 rounded-lg px-2 py-1.5">
                  <div class="text-sm">${titleCase(it.item||"")}</div>
                  <div class="text-sm font-semibold">‚è≤ ${fmtCountdownShort(untilDoneMs)}</div>
                </div>
              `;
            }).join("")}
          </div>
        ` : `
          <div class="text-sm text-neutral-400">üî• Nothing in oven right now</div>
        `}

        ${lastEvent ? `
          <div class="text-xs text-neutral-500 mt-1">Last event: ${capFirst(lastEvent.action)} ‚Äî ${titleCase(lastEvent.item||"")} (${lastEvent.time})</div>
        ` : ``}
      </div>

      <div class="bg-neutral-900 border border-neutral-800 rounded-xl p-3 space-y-2">
        <div class="text-xs uppercase tracking-widest text-neutral-500">next</div>

        ${nextEvent ? `
          <div class="text-sm font-medium">
            ${capFirst(nextEvent.action)} ‚Äî ${titleCase(nextEvent.item||"")}
          </div>
          <div class="text-xs text-neutral-400">
            Planned: ${nextEvent.time}
            ${nextEvent.person?` ‚Ä¢ üë§ ${titleCase(nextEvent.person)}`:""}
            ${nextEvent.action==="set oven temp" && nextEvent.temp!=="‚Äî" ? ` ‚Ä¢ ‚Üí ${nextEvent.temp}¬∞F` : ``}
          </div>
          <div class="text-2xl font-bold mt-1">‚è≥ ${fmtCountdownHours(nextEvent.offsetMs - eMs)}</div>
        ` : `
          <div class="text-sm text-neutral-400">No upcoming events left üéâ</div>
        `}
      </div>
    </div>

    <div class="bg-neutral-900 border border-neutral-800 rounded-xl p-3 space-y-2">
      <div class="text-xs uppercase tracking-widest text-neutral-500">runway (next up)</div>
      ${runway.length ? `
        <div class="space-y-2">
          ${runway.map(ev=>{
            const rem = ev.offsetMs - eMs;
            const soon = rem <= 10*60*1000;
            return `
              <div class="flex items-center justify-between bg-neutral-950 border border-neutral-800 rounded-lg px-3 py-2">
                <div>
                  <div class="text-sm font-medium">
                    ${capFirst(ev.action)} ‚Äî ${titleCase(ev.item||"")}
                  </div>
                  <div class="text-xs text-neutral-400">
                    ${ev.time}
                    ${ev.person?` ‚Ä¢ üë§ ${titleCase(ev.person)}`:""}
                    ${ev.action==="set oven temp" && ev.temp!=="‚Äî" ? ` ‚Ä¢ ‚Üí ${ev.temp}¬∞F` : ``}
                  </div>
                </div>
                <div class="text-sm font-semibold ${soon?"text-amber-300":"text-neutral-100"}">
                  ${fmtCountdownHours(rem)}
                </div>
              </div>
            `;
          }).join("")}
        </div>
      ` : `
        <div class="text-sm text-neutral-400">Nothing else scheduled.</div>
      `}
    </div>
  `;
}

function renderDashScrubber(){
  if(anchorMin == null) return `<div class="text-sm text-neutral-400">Add parseable times in Plan to see timeline.</div>`;
  const events = getSortedPlannerEvents();
  if(!events.length) return `<div class="text-sm text-neutral-400">No scheduled events yet.</div>`;

  window.__selectedScrubId = window.__selectedScrubId || null;
  const selectedId = window.__selectedScrubId;

  const totalMs = (events[events.length-1].offsetMs - events[0].offsetMs) || 1;
  const eMs = hasStarted() ? elapsedMs() : 0;
  const pctNow = Math.min(100, Math.max(0, (eMs / totalMs) * 100));

  const minGapPct = 6;
  const laneLastPct = [-Infinity, -Infinity, -Infinity];
  const laneOffsetsPx = [16, 30, 44];

  const dotsWithLanes = events.map((ev) => {
    const leftPct = ((ev.offsetMs - events[0].offsetMs) / totalMs) * 100;
    let lane = lanesFind(leftPct);
    laneLastPct[lane] = leftPct;
    return { ...ev, leftPct, lane };
    function lanesFind(lp){
      let l = laneLastPct.findIndex(last => (lp - last) >= minGapPct);
      if(l < 0){
        const minLast = Math.min(...laneLastPct);
        l = laneLastPct.indexOf(minLast);
      }
      return l;
    }
  });

  const dotHtml = dotsWithLanes.map(ev=>{
    const isTemp  = ev.action === "set oven temp";
    const isServe = ev.action === "serve";
    const overdue = hasStarted() && ev.action==="put in" && eMs > ev.offsetMs;

    const dotClass = isServe ? "bg-amber-300" : isTemp ? "bg-sky-400" : "bg-emerald-400";
    const pulseClass = overdue ? "ring-2 ring-rose-400/80" : "";
    const selectedClass = ev.id === selectedId ? "ring-2 ring-white/90" : "";

    const labelTop = laneOffsetsPx[ev.lane] ?? 16;

    return `
      <button
        class="absolute top-1/2 -translate-y-1/2 w-4 h-4 rounded-full ${dotClass} ${pulseClass} ${selectedClass}"
        style="left:${ev.leftPct}%"
        data-scrub-id="${ev.id}"
      ></button>
      <div class="absolute text-[10px] text-neutral-300 whitespace-nowrap -translate-x-1/2 select-none"
           style="left:${ev.leftPct}%; top: calc(50% + ${labelTop}px);">
        ${ev.time}
      </div>
    `;
  }).join("");

  const nowLine = hasStarted()
    ? `<div class="absolute top-0 bottom-0 w-[3px] bg-white/80 shadow" style="left:${pctNow}%"></div>`
    : `<div class="absolute top-0 bottom-0 w-[3px] bg-white/20" style="left:0%"></div>`;

  const selectedEv = selectedId ? dotsWithLanes.find(e => e.id === selectedId) : null;

  return `
    <div class="space-y-2">
      <div class="text-xs uppercase tracking-widest text-neutral-500">timeline</div>
      <div class="relative h-24 bg-neutral-900 border border-neutral-800 rounded-2xl px-3">
        <div class="absolute left-3 right-3 top-1/2 -translate-y-1/2 h-2 rounded-full bg-neutral-800"></div>
        ${nowLine}
        ${dotHtml}
      </div>
      <div class="flex items-center justify-between text-xs text-neutral-500">
        <div>${events[0].time}</div>
        <div>${events[events.length-1].time}</div>
      </div>

      ${selectedEv ? `
        <div class="mt-2 bg-neutral-950 border border-neutral-800 rounded-xl p-3 text-sm">
          <div class="text-xs uppercase tracking-widest text-neutral-500">selected event</div>
          <div class="mt-1 font-semibold">${capFirst(selectedEv.action)} ‚Äî ${titleCase(selectedEv.item || "(no item)")}</div>
          <div class="text-xs text-neutral-400 mt-0.5">
            Time: ${selectedEv.time}
            ${selectedEv.temp !== "‚Äî" ? ` ‚Ä¢ Temp: ${selectedEv.temp}¬∞F` : ``}
            ${selectedEv.person ? ` ‚Ä¢ üë§ ${titleCase(selectedEv.person)}` : ``}
          </div>
          <div class="text-xs text-neutral-500 mt-1">Tap another dot to switch.</div>
        </div>
      ` : `<div class="text-xs text-neutral-500 mt-1">Tap a dot to see details.</div>`}
    </div>
  `;
}

function renderDash(){
  renderDashNowNext();
  const live = hasStarted();
  const eMs = live ? elapsedMs() : 0;

  let dinnerHtml = "";
  if(!live || dinnerOffsetMs==null){
    dinnerHtml = `
      <div class="text-xs uppercase tracking-widest text-neutral-500">countdown to dinner</div>
      <div class="text-4xl md:text-6xl font-bold mt-2">start cook</div>
      <div class="text-neutral-400 text-sm mt-1">dinner time uses your serve row (or last done dish).</div>
    `;
  } else {
    const remMs = Math.max(0, dinnerOffsetMs - eMs);
    const dinnerTs = effectiveNowTs() + remMs;
    const dinnerPct = dinnerOffsetMs ? Math.round((eMs/dinnerOffsetMs)*100) : 0;
    dinnerHtml = `
      <div class="text-xs uppercase tracking-widest text-neutral-500">countdown to dinner</div>
      <div class="flex items-start justify-between gap-3 mt-2">
        <div class="text-5xl md:text-7xl font-bold">${fmtCountdownHours(remMs)}</div>
        ${ringHTML(dinnerPct, "dinner")}
      </div>
      <div class="text-neutral-300 mt-2 text-sm">serve at ${timeStrFromDate(new Date(dinnerTs))}</div>
    `;
  }

  const pastTemp = getSortedPlannerEvents()
    .filter(ev => ev.action==="set oven temp" && ev.temp!=="‚Äî" && ev.offsetMs<=eMs)
    .slice(-1)[0];

  const nextTemp = getSortedPlannerEvents()
    .find(ev => ev.action==="set oven temp" && ev.temp!=="‚Äî" && ev.offsetMs>eMs);

  dashDinner.innerHTML = `
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-3">
      <div class="lg:col-span-2 bg-neutral-950 border border-neutral-800 rounded-3xl p-6">${dinnerHtml}</div>
      <div class="bg-neutral-950 border border-neutral-800 rounded-3xl p-6">
        <div class="text-xs uppercase tracking-widest text-neutral-500">oven temp</div>
        <div class="text-4xl md:text-5xl font-bold mt-2">${pastTemp ? `${pastTemp.temp}¬∞F` : "‚Äî"}</div>
        <div class="text-sm text-neutral-400 mt-1">${pastTemp ? `set at ${pastTemp.time}` : "no active target yet"}</div>
        ${nextTemp && live ? `
          <div class="mt-4 bg-neutral-900 border border-neutral-800 rounded-xl p-3">
            <div class="text-xs text-neutral-500 uppercase tracking-widest">next change</div>
            <div class="text-lg font-semibold mt-1">‚Üí ${nextTemp.temp}¬∞F at ${nextTemp.time}</div>
            <div class="text-2xl font-bold mt-1">in ${fmtCountdownHours(nextTemp.offsetMs - eMs)}</div>
          </div>` : ``}
      </div>
    </div>
  `;

  const prepTotalsAll = taskTotals(prepTasks);
  const prepPct = prepTotalsAll.grandTotal ? Math.round(prepTotalsAll.grandDone/prepTotalsAll.grandTotal*100) : 0;
  const totalOven = timerItems.length;
  const doneOven = totalOven ? timerItems.filter(t => live && eMs >= t.doneOffsetMs).length : 0;
  const ovenPct = totalOven ? Math.round(doneOven/totalOven*100) : 0;

  dashBars.innerHTML = `
    ${renderDashScrubber()}
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-3">
      <div>
        <div class="flex items-center justify-between text-base mb-2"><span>prep completion</span><span>${prepPct}%</span></div>
        <div class="bar h-3"><div style="width:${prepPct}%"></div></div>
      </div>
      <div>
        <div class="flex items-center justify-between text-base mb-2"><span>oven timeline</span><span>${ovenPct}%</span></div>
        <div class="bar h-3"><div style="width:${ovenPct}%"></div></div>
      </div>
    </div>
  `;

  dashNumbers.innerHTML = `
    <div class="text-xs uppercase tracking-widest text-neutral-500">quick stats</div>
    <div class="text-lg">prep ${prepTotalsAll.grandDone}/${prepTotalsAll.grandTotal}</div>
    <div class="text-xs text-neutral-500">(${prepTotalsAll.parentsTotal} tasks + ${prepTotalsAll.subsTotal} subtasks)</div>
    <div class="text-lg">oven done ${doneOven}/${totalOven}</div>
    <div class="text-lg">temp changes left ${tempChangeItems.length}</div>
  `;

  dashBars.querySelectorAll("[data-scrub-id]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-scrub-id");
      window.__selectedScrubId = id;
      renderDash();
    });
  });
}

/* ---------------------------
   DATA TAB CHARTS (cleaner labels)
----------------------------*/
function renderData(){
  const live = hasStarted();
  const eMs = live ? elapsedMs() : 0;

  const totalRange = (dinnerOffsetMs ?? finalDoneOffsetMs ?? 0);
  const rangeMin = totalRange ? Math.round(totalRange/60000) : 0;

  const ovenCount = timerItems.length;
  const prepTotalsAll = taskTotals(prepTasks);
  const prepPct = prepTotalsAll.grandTotal ? Math.round(prepTotalsAll.grandDone/prepTotalsAll.grandTotal*100) : 0;

  dataSummary.innerHTML = `
    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
      <div class="bg-neutral-900 border border-neutral-800 rounded-xl p-4">
        <div class="text-xs uppercase tracking-widest text-neutral-500">total planned span</div>
        <div class="text-3xl font-semibold mt-1">${rangeMin ? rangeMin+" min" : "‚Äî"}</div>
        <div class="text-xs text-neutral-400 mt-1">from first planned time to serve/final dish</div>
      </div>
      <div class="bg-neutral-900 border border-neutral-800 rounded-xl p-4">
        <div class="text-xs uppercase tracking-widest text-neutral-500">oven dishes</div>
        <div class="text-3xl font-semibold mt-1">${ovenCount}</div>
        <div class="text-xs text-neutral-400 mt-1">timed ‚Äúput in‚Äù items</div>
      </div>
      <div class="bg-neutral-900 border border-neutral-800 rounded-xl p-4">
        <div class="text-xs uppercase tracking-widest text-neutral-500">prep completion</div>
        <div class="text-3xl font-semibold mt-1">${prepPct}%</div>
        <div class="text-xs text-neutral-400 mt-1">${prepTotalsAll.grandDone}/${prepTotalsAll.grandTotal} tasks + subtasks done</div>
      </div>
    </div>
  `;

  renderGanttChart(totalRange, eMs);
  renderOvenLoadChart(totalRange, eMs);
  renderTempScheduleChart(totalRange, eMs);
  saveState(true);
}

function renderGanttChart(totalRangeMs, eMs){
  if(!totalRangeMs || !timerItems.length){
    dataGantt.innerHTML = `<div class="text-sm text-neutral-400">Add timed ‚Äúput in‚Äù rows to see an oven gantt.</div>`;
    dataGanttDetails.textContent = "Tap a block for details.";
    return;
  }

  const W = 980;
  const rowH = 30;
  const padL = 150, padR = 18, padT = 26, padB = 34;

  const lanes = [];
  const items = timerItems.map(it=>({...it}));
  items.forEach(it=>{
    let lane = lanes.findIndex(endMs => it.inOffsetMs >= endMs);
    if(lane < 0){ lane = lanes.length; lanes.push(0); }
    lanes[lane] = it.doneOffsetMs;
    it.lane = lane;
  });

  const height = padT + (lanes.length * rowH) + padB;
  const xScale = (ms)=> padL + (ms/totalRangeMs)*(W-padL-padR);
  const nowX = xScale(Math.max(0, Math.min(totalRangeMs, eMs)));

  // left-side lane labels (no overlap)
  const laneLabels = items.map(it=>{
    const y = padT + it.lane*rowH + 14;
    return `<text x="10" y="${y}" font-size="11" fill="rgba(255,255,255,0.85)">${titleCase(it.item||"(unnamed)")}</text>`;
  }).join("");

  const blocks = items.map(it=>{
    const x = xScale(it.inOffsetMs);
    const w = Math.max(3, xScale(it.doneOffsetMs) - xScale(it.inOffsetMs));
    const y = padT + it.lane*rowH;
    const isActive = eMs>=it.inOffsetMs && eMs<it.doneOffsetMs;
    const isOver = eMs>=it.doneOffsetMs;
    const fill = isOver ? "rgba(16,185,129,0.28)" : isActive ? "rgba(245,158,11,0.28)" : "rgba(99,102,241,0.20)";
    const stroke = isOver ? "rgba(16,185,129,0.95)" : isActive ? "rgba(245,158,11,0.95)" : "rgba(99,102,241,0.8)";

    const selected = dataSelected.gantt === it.id;
    const selStroke = selected ? "rgba(255,255,255,0.95)" : stroke;
    const selWidth = selected ? 2.4 : 1.2;

    return `
      <rect data-gantt-id="${it.id}" x="${x}" y="${y}" rx="6" ry="6" width="${w}" height="18"
            fill="${fill}" stroke="${selStroke}" stroke-width="${selWidth}" style="cursor:pointer"></rect>
    `;
  }).join("");

  const tickEveryMin = 30;
  const tickCount = Math.floor((totalRangeMs/60000)/tickEveryMin)+1;
  const ticks = Array.from({length: tickCount}, (_,i)=>{
    const min = i*tickEveryMin;
    const x = xScale(min*60000);
    const timeLabel = timeStrFromMinutes(anchorMin + min);
    return `
      <g>
        <line x1="${x}" y1="${padT-10}" x2="${x}" y2="${height-padB+6}" stroke="rgba(255,255,255,0.06)"></line>
        <text x="${x}" y="${height-8}" font-size="10" fill="rgba(255,255,255,0.55)" text-anchor="middle">${timeLabel}</text>
      </g>
    `;
  }).join("");

  dataGantt.innerHTML = `
    <svg id="svg-gantt" width="100%" height="${height}" viewBox="0 0 ${W} ${height}">
      ${ticks}
      <line x1="${nowX}" y1="${padT-10}" x2="${nowX}" y2="${height-padB+6}"
            stroke="rgba(255,255,255,0.9)" stroke-width="2"></line>
      ${laneLabels}
      ${blocks}
      <text x="${padL}" y="14" font-size="11" fill="rgba(255,255,255,0.6)">tap a bar for details</text>
    </svg>
  `;

  const selectedId = dataSelected.gantt;
  if(selectedId){
    const it = timerItems.find(x=>x.id===selectedId);
    if(it){
      const toMin = parseTimeToMinutes(it.plannedTime)+it.cookMin;
      dataGanttDetails.textContent =
        `${titleCase(it.item||"")}: planned ${it.plannedTime}, cook ${it.cookMin} min, take out ~${timeStrFromMinutes(toMin)}.`;
    }
  } else dataGanttDetails.textContent = "Tap a bar for details.";

  document.getElementById("svg-gantt")
    ?.querySelectorAll("[data-gantt-id]")
    .forEach(rect=>{
      rect.addEventListener("click", ()=>{
        dataSelected.gantt = rect.getAttribute("data-gantt-id");
        renderData();
      });
    });
}

function renderOvenLoadChart(totalRangeMs, eMs){
  if(!totalRangeMs || !timerItems.length){
    dataLoad.innerHTML = `<div class="text-sm text-neutral-400">Add timed ‚Äúput in‚Äù rows to see oven load.</div>`;
    dataLoadDetails.textContent = "Tap a step point for details.";
    return;
  }

  const W = 980, H = 240;
  const padL = 60, padR = 18, padT = 18, padB = 32;

  const events = [];
  timerItems.forEach(t=>{
    events.push({ t: t.inOffsetMs, delta: +1, dishId: t.id, type: "in" });
    events.push({ t: t.doneOffsetMs, delta: -1, dishId: t.id, type: "out" });
  });
  events.sort((a,b)=>a.t-b.t);

  let load=0;
  const series=[{x:0,y:0, type:"start"}];
  events.forEach(e=>{
    load += e.delta;
    series.push({ x: e.t, y: load, dishId: e.dishId, type: e.type });
  });
  series.push({ x: totalRangeMs, y: load, type:"end" });

  const maxLoad = Math.max(1, ...series.map(p=>p.y));
  const xScale = (ms)=> padL + (ms/totalRangeMs)*(W-padL-padR);
  const yScale = (v)=> padT + (1 - v/maxLoad)*(H-padT-padB);

  const stepPath = () => {
    let d = `M ${xScale(series[0].x)} ${yScale(series[0].y)}`;
    for(let i=1;i<series.length;i++){
      const prev = series[i-1];
      const cur = series[i];
      d += ` L ${xScale(cur.x)} ${yScale(prev.y)} L ${xScale(cur.x)} ${yScale(cur.y)}`;
    }
    return d;
  };

  const nowX = xScale(Math.max(0, Math.min(totalRangeMs, eMs)));

  const pickable = series.filter(p=>p.type==="in" || p.type==="out");

  dataLoad.innerHTML = `
    <svg id="svg-load" width="100%" height="${H}" viewBox="0 0 ${W} ${H}">
      <path d="${stepPath()} L ${xScale(totalRangeMs)} ${yScale(0)} L ${xScale(0)} ${yScale(0)} Z" fill="rgba(16,185,129,0.18)"></path>
      <path d="${stepPath()}" fill="none" stroke="rgba(16,185,129,0.9)" stroke-width="2"></path>

      ${pickable.map((p,i)=>`
        <circle data-load-idx="${i}" cx="${xScale(p.x)}" cy="${yScale(p.y)}" r="5"
                fill="rgba(16,185,129,1)" style="cursor:pointer"></circle>
      `).join("")}

      <line x1="${nowX}" y1="${padT-2}" x2="${nowX}" y2="${H-padB}"
            stroke="rgba(255,255,255,0.9)" stroke-width="2"></line>

      ${Array.from({length:maxLoad+1}, (_,i)=>{
        const y = yScale(i);
        return `
          <line x1="${padL}" y1="${y}" x2="${W-padR}" y2="${y}" stroke="rgba(255,255,255,0.06)"></line>
          <text x="${padL-8}" y="${y+4}" font-size="10" fill="rgba(255,255,255,0.6)" text-anchor="end">${i}</text>
        `;
      }).join("")}
    </svg>
  `;

  const selectedIdx = dataSelected.load;
  if(selectedIdx != null){
    const p = pickable[selectedIdx];
    if(p){
      const dish = timerItems.find(x=>x.id===p.dishId);
      const when = timeStrFromMinutes(anchorMin + Math.round(p.x/60000));
      const label = dish ? titleCase(dish.item||"") : "dish";
      dataLoadDetails.textContent = `${when}: ${label} ${p.type==="in" ? "went in" : "came out"} (oven load now ${p.y}).`;
    }
  } else dataLoadDetails.textContent = "Tap a step point for details.";

  document.getElementById("svg-load")
    ?.querySelectorAll("[data-load-idx]")
    .forEach((c,i)=>{
      c.addEventListener("click", ()=>{
        dataSelected.load = i;
        renderData();
      });
    });
}

function renderTempScheduleChart(totalRangeMs, eMs){
  if(!totalRangeMs || !tempChangeItems.length){
    dataTemps.innerHTML = `<div class="text-sm text-neutral-400">No temp change rows with parseable times yet.</div>`;
    dataTempsDetails.textContent = "Tap a temp change for details.";
    return;
  }

  const W = 980, H = 240;
  const padL = 68, padR = 18, padT = 18, padB = 32;

  const tempsSeries = tempChangeItems
    .filter(tc=>tc.targetTemp)
    .map(tc=>({ x: tc.offsetMs, y: tc.targetTemp, id: tc.id, time: tc.time }))
    .sort((a,b)=>a.x-b.x);

  const minTemp = Math.min(...tempsSeries.map(p=>p.y), 300);
  const maxTemp = Math.max(...tempsSeries.map(p=>p.y), 450);

  const xScale = (ms)=> padL + (ms/totalRangeMs)*(W-padL-padR);
  const yScale = (v)=> padT + (1 - (v-minTemp)/(maxTemp-minTemp || 1))*(H-padT-padB);

  let d = `M ${xScale(0)} ${yScale(tempsSeries[0].y)}`;
  tempsSeries.forEach((p,i)=>{
    d += ` L ${xScale(p.x)} ${yScale(i===0?tempsSeries[0].y:tempsSeries[i-1].y)} L ${xScale(p.x)} ${yScale(p.y)}`;
  });
  d += ` L ${xScale(totalRangeMs)} ${yScale(tempsSeries[tempsSeries.length-1].y)}`;

  const nowX = xScale(Math.max(0, Math.min(totalRangeMs, eMs)));

  dataTemps.innerHTML = `
    <svg id="svg-temps" width="100%" height="${H}" viewBox="0 0 ${W} ${H}">
      <path d="${d}" fill="none" stroke="rgba(56,189,248,0.95)" stroke-width="2.8"></path>

      ${tempsSeries.map((p,i)=>`
        <circle data-temp-idx="${i}" cx="${xScale(p.x)}" cy="${yScale(p.y)}" r="6"
                fill="rgba(56,189,248,1)" style="cursor:pointer"></circle>
        <text x="${xScale(p.x)}" y="${yScale(p.y)-8}" font-size="10" fill="rgba(255,255,255,0.8)" text-anchor="middle">${p.y}¬∞F</text>
      `).join("")}

      <line x1="${nowX}" y1="${padT-2}" x2="${nowX}" y2="${H-padB}"
            stroke="rgba(255,255,255,0.9)" stroke-width="2"></line>

      ${Array.from({length:5}, (_,i)=>{
        const v = minTemp + i*(maxTemp-minTemp)/4;
        const y = yScale(v);
        return `
          <line x1="${padL}" y1="${y}" x2="${W-padR}" y2="${y}" stroke="rgba(255,255,255,0.06)"></line>
          <text x="${padL-8}" y="${y+4}" font-size="10" fill="rgba(255,255,255,0.6)" text-anchor="end">${Math.round(v)}¬∞F</text>
        `;
      }).join("")}
    </svg>
  `;

  const selectedIdx = dataSelected.temps;
  if(selectedIdx != null){
    const p = tempsSeries[selectedIdx];
    if(p) dataTempsDetails.textContent = `${p.time}: set oven to ${p.y}¬∞F.`;
  } else dataTempsDetails.textContent = "Tap a temp change for details.";

  document.getElementById("svg-temps")
    ?.querySelectorAll("[data-temp-idx]")
    .forEach((c,i)=>{
      c.addEventListener("click", ()=>{
        dataSelected.temps = i;
        renderData();
      });
    });
}

/* ---------------------------
   VIEW SWITCHING
----------------------------*/
function setView(next){
  view=next;

  viewPlan.classList.toggle("hidden", view!=="plan");
  viewPrep.classList.toggle("hidden", view!=="prep");
  viewRun.classList.toggle("hidden",  view!=="run");
  viewDash.classList.toggle("hidden", view!=="dash");
  viewData.classList.toggle("hidden", view!=="data");

  const on = "px-3 py-1.5 rounded-xl text-sm transition bg-neutral-800 text-white";
  const off = "px-3 py-1.5 rounded-xl text-sm transition text-neutral-400 hover:text-white";
  tabPlan.className = view==="plan"?on:off;
  tabPrep.className = view==="prep"?on:off;
  tabRun.className  = view==="run"?on:off;
  tabDash.className = view==="dash"?on:off;
  tabData.className = view==="data"?on:off;

  if(view==="prep") renderPrep();
  if(view==="run") renderRun();
  if(view==="dash") renderDash();
  if(view==="data") renderData();
  if(view==="plan") renderPlan();

  saveState(true);
}

/* ---------------------------
   EVENT WIRES
----------------------------*/
tabPlan.addEventListener("click",()=>setView("plan"));
tabPrep.addEventListener("click",()=>setView("prep"));
tabRun.addEventListener("click",()=>setView("run"));
tabDash.addEventListener("click",()=>setView("dash"));
tabData.addEventListener("click",()=>setView("data"));

btnSortTime.addEventListener("click", sortTimelineByTime);

btnAddRow.addEventListener("click",()=>{
  timeline.push({id:uuid(),time:"",temp:350,action:"put in",item:"",cookMin:10,person:""});
  renderPlan(); rebuildTimers(); seedPrepTasks(false); saveState();
});
btnResetTemplate.addEventListener("click",()=>{
  timeline=DEFAULT_TIMELINE.map(r=>({id:uuid(),...r}));
  prepTasks = prepTasks.filter(t=>!t.sourceRowId);
  resetRun(); renderPlan(); rebuildTimers(); seedPrepTasks(true); saveState();
});
btnStartCook.addEventListener("click",startRun);

btnRunStart.addEventListener("click", startRun);
btnRunPause.addEventListener("click", pauseRun);
btnRunResume.addEventListener("click", resumeRun);
btnRunReset.addEventListener("click", resetRun);

btnPrepAdd.addEventListener("click",()=>addPrepTask(prepPersonInput.value, prepTaskInput.value));
btnPrepSeed.addEventListener("click",()=>seedPrepTasks(true));
btnPrepBulkAdd.addEventListener("click", addPrepTasksBulk);
btnPrepRandom.addEventListener("click", pickRandomPrepTask);

btnDashRefresh.addEventListener("click",()=>renderDash());
btnDataRefresh.addEventListener("click",()=>renderData());

btnSave.addEventListener("click",()=>saveState());
btnClearAll.addEventListener("click",()=>{
  if(!confirm("Clear everything and reset to template?")) return;
  clearState();
  timeline = DEFAULT_TIMELINE.map(r=>({id:uuid(),...r}));
  prepTasks = [];
  startedAtTs = null; isRunning=false; pausedAtTs=null; pausedAccumMs=0; activeDelay=null;
  acknowledgedDoneIds.clear();
  chimeFiredInIds.clear();
  stopTicking();
  dataSelected = { gantt:null, load:null, temps:null };
  renderPlan(); rebuildTimers(); seedPrepTasks(true); setView("plan"); saveState();
});

/* ---------------------------
   INIT
----------------------------*/
loadState();
renderPlan();
rebuildTimers();
seedPrepTasks(true);
setView(view || "plan");
if(startedAtTs) startTicking();
</script>
</body>
</html>
